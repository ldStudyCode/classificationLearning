【以下内容，基于JAVA语言，切换语言会有不兼容情况】
[TOC]
# 并发要解决的本质东西：线程安全

## 线程安全有哪些级别？
- ==不可变==：String、加final修饰的等【常量】，永远线程安全
- 【x】绝对线程安全：一个变量，不可能实现对他如何操作都可以自动线程安全，因此不可能实现
- ==相对线程安全==：一堆可以自主实现线程安全的变量，对变量操作可以实现线程安全
- ==线程兼容==：线程不安全的变量，管一下能实现线程安全。
- 【x】线程对立：变量怎么管，都管不住，Java中不会出现这种现象。

## 线程安全怎么实现？
- 不可变、相对线程安全，安全了，不用管(而这个不用管了，java还给了一个特殊的名字叫无同步方案)。
    - ==细节注意==：如threadlocal是实现无同步方案的一种方法。
- 线程兼容，加锁\cas进行控制。
- 简而言之，线程安全，要么通过加锁实现，要么不用管。

# JAVA里的锁是什么，有哪些？
- 车轱辘问题，锁是保证线程安全的东西（保证线程安全要用锁）
- JAVA里不光是简单的有哪些锁，还很细的分成了几类，==因该问有哪几类锁==
    - 阻塞同步【互斥同步、悲观锁、排他锁】
        - ==细节注意==：拿不到锁的进程会阻塞，而让线程阻塞这件事，是CPU做的，CPU做这件事，需要切换内核态\用户态，高消耗。
        - synchronized（可重入\递归锁）
            - 对象锁，锁对象或Class类(static方法)
        - reentrantLock（可重入\递归锁）
            - 对象锁，锁对象或Class类(static方法)
            - ==他比synchronized特别（好）在哪?==
                - 拿锁的时候可以定时获取锁
                - 可以实现公平锁，谁等的时间长，谁能先拿到锁
                - 等待抢同一把锁的人还能内部分组，LinkedBlockingDequeue
            - ==他比synchronized辣鸡在哪？==
                - 用着麻烦，更容易用错。
                - 还得new一个对象当锁
                - 需要用lock()和unlock()方法，上锁和解锁，容易忘，有时候还不好写(finally)
                - 性能优化追不上synchronized
    - 非阻塞同步【乐观锁】
        - cas操作（先比较后交换）
            - 先拿出来与之前一次拿出来的值做比较，如果两值相等，则修改该值
            - ==细节注意==：非阻塞同步是“先计算再赋值”这个整体，而cas操作是这个整体中的一小部分。因此非阻塞同步是cas操作这件事是错的。

# JAVA里的锁，除了以上类别，还有哪些分类，哪些没讲到的锁？

## 没讲到的锁
- ReadWriteLock读写锁
    - readlock可以共享

## 没讲到的分类【直接列全一些的】
- 公平/非公平锁
    - synchroniezd，非
    - reentrantlock，可设置为公
- 可重入/不可重入锁
    - 均可重入
- 独享/共享锁
    - 独：synchronized、reentrantlock
    - 共：readwritelock
- 互斥/读写锁
    - 同上
- 乐观/悲观锁
    - 乐：cas
    - 悲：syn、reent、readwrite？
- 分段锁
    - 应该说成是“锁的分段”，即细分锁粒度的一种方式
    - 锁分解
        - 缩小一个锁的范围
        - 将一个锁分成多个锁（对一个代码而言）
    - 锁分段
        - 讲一个锁分成多个锁（对一个数据结构而言）
- 偏向/轻量级/重量级锁
    - 针对synchronized
    - java5引入，锁升级的机制
- 自旋锁
    - 应该说成是“锁的自旋”
    - 一句话：尝试获取锁的线程，循环多次获取锁，再拿不到锁后阻塞。
    - 二句话：从直接消耗cpu切换内核/用户态、到先消耗cpu“尝试获取锁”，不行再消耗cpu切换用户/内核态


# 锁完事儿了，锁是怎么优化的呢？
- 编译的时候：
    - 锁消除
        - 逃逸分析
            - 方法逃逸：对象的指针被当作其他方法的参数了
            - 线程逃逸：外部线程拿到这个对象的指针了
            - 对于不会产生方法逃逸的，==栈上分配==
            - 对于不会产生线程逃逸的，==锁消除== + ==标量替换==（把对象的聚合量放在栈上创建）
    - 锁粗化
        - 循环内的加锁逻辑，放到循环外
- 运行的时候：
    - 偏向锁
        - ==细节注意==：认为只有自己一个线程在用这个对象
        - 初始化，1次cas操作设置owner，成功则标记该线程为owner，失败则膨胀
        - 过程中每次owner不变，则继续直接访问
        - 发现owner变化，则膨胀
        - ![偏向锁](http://note.youdao.com/yws/res/25167/WEBRESOURCE1fd71102a1bba7666aa46d853db8acca)
        - 缺点：高并发会频繁撤销偏向锁（进入安全点）
        - jvm:
            - 激活偏向锁延迟：-XX:BiasedLockingStartupDelay=0
            - 关闭偏向锁：-XX:-UseBiasedLocking=false
    - 轻量级锁
        - ==细节注意==：认为有多个线程同时在用，但是由于并发量小，我们几乎碰不到面
        - cas操作 + 一次自旋操作
        - 不灵，则膨胀
        - ![轻量级锁及其膨胀](http://note.youdao.com/yws/res/25181/WEBRESOURCEc71e4ffe02e6cb55ec775e6fdbf4b796)
        - jvm：
            - jdk1.6：
                - -XX:+UseSpinning开启
                - -XX:PreBlockSpin=10 为自旋次数
            - jdk1.7:
                - jvm自己控制
    - 重量锁
        - ==没啥细节==：该啥就啥
    - 适应性自旋锁
        - jvm自己管理自旋
        - 通过增加cpu开销的形式，来减少cpu的开销（减少cpu的状态切换）

# 锁优化完事了，还没有结束，看看java自己给自己挖的坑，以及这些坑是怎么填的？
## java自己给自己挖了哪些坑？
### 1、指令集重排序
- 为啥要指令重排序？
    - 提高程序执行效率
    - 排序后a 或 b有可能有机会留在寄存器中
```
int a = 1;
int b = 1;
a = a + 1;
b = b +1 ;

int a = 1;
a = a + 1;
int b = 1;
b = b + a;
```
- 啥时候重排序，什么样的代码可以重排序？
    - 代码之间没有前后关系
```
double pi  = 3.14;    //A
double r   = 1.0;     //B
double area = pi * r * r; //C  

a --> c
b --> c

a、b之间可重排序
```
- 坑在哪了？
    - 可重排序的代码，有可能排序完之后 + 多线程执行，出现问题。
```
class ReorderExample {
int a = 0;
boolean flag = false;

public void writer() {
    a = 1;                   //1
    flag = true;             //2
}

Public void reader() {
    if (flag) {                //3
        int i =  a * a;        //4
        ……
    }
}
} 
```
- 怎么办？
    - volatile
        - 禁止变量参与指令集重排序
        - 保证变量对所有线程的可见性

### 2、内存一致性
- 啥是内存一致性，多个内存指的是哪些？
    - 目的还是提高效率，工作内存的内容会优先往寄存器和cpu缓存中放
    - （不做工作内存，也不知道该把谁一上来就放到寄存器和cpu缓存中去了）
    - ![java内存模型](https://note.youdao.com/src/WEBRESOURCEa9abdd5b7ddfbaa9202e7df511ab2fe6)
- 内存一致性问题在哪？
    - 问题在于，他他娘的是分步骤做的，且一个东西存了多份，各自修改，各自看不见各自的修改 
    - 对于锁：
        - lock、unlock
    - 对于线程使用：
        - read、load、use
    - 对于线程修改：
        - assign、store、write
    - ![8种原子性操作](https://note.youdao.com/src/WEBRESOURCE3fbdc00396bae3970683f7bad07b47de)
- 怎么办？
    - volatile
        - assign、store、write操作绑定在一起【这就是内存屏障，强制让缓存区内容失效】
        - read、load、use操作绑定在一起
        - 每次修改，通知其他人，你们自己手里的变量过期了，来主存再取一份
- 写操作好理解，读操作内存屏障举例？
    - long型的读。

## 坑用volatile就填完了嘛？
- 对于一个volatile的变量，一个人正在写，写到一半，另一个人开始读，怎么办？
    - 先行发生原则【等到A执行完了，B才允许执行】：
    - ![先行发生原则](https://note.youdao.com/src/WEBRESOURCEa4b1984401ba5c48dbd30b2ecf6684f7)

## 锁操作之于这些坑的讨论
- 由于java的锁都是非抢占的，因此加锁后，锁住的代码段一定全部都是单线程执行，不存在指令集重排序后造成的坑。
- 由于java的锁锁住的是公共内存的对象，因此加锁后，其他本地内存的对象副本都会失效，不存在内存一致性问题。



# 线程安全的类，怎么写？
- 线程安全的类的本质：==对象的安全==
- 没搞明白，下次再分解